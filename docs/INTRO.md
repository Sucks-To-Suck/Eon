Welcome to the Intro:
----------

The intro will be like a whitepaper, but without all of the technical specifications that the whitepaper will have. I am writting this intro for 2 reasons, one is because at the time of writting this, I have yet to make all of the final design decisions so I simply cannot provide all of the technical detail. The other reason is I would like to have a spot to put all of my thoughts of planning down for later. Now, lets get started.

A Brief Summary of what Luncheon is:
----------

Luncheon will be a network, as you can guess from the name "Luncheon Network", but what will it do? The main goal of this network is a step above what ethereums is, as the goal here will be application execution, rather than eths limited smart contract execution. What I mean by that is that applications can be written in a general purpose scripting language and will be deployed on the network, spreading the application around the world, so users from all over can easily access / use your application. This network wont bne as fexible for developers as lets say an aws server is, but it will provide fast speeds, well tested security, and easy deployment. Continue reading for more context on that.

Lets get the basics out of the way; What About Security?
----------

- The base level security:

The network will provide security for applications in many ways. First lets start off with how data will be saved on the network. Any data transaction (not nessesarily financial, just any transaction deemed valuable to save in history) can be saved on the base level blockchain. Blockchain data storage has been proven by many other projects that its strength in ensuring data transaction history is unbeaten with the right protocols in place. Blockchain on a basic level is just a block of information (just a set size of info) that you get the hash of and save (more on hashes later). Hashes take any input data size and give a unique and fixed size output. This means of the data in the past is changed, the unique hash of that block of information will change, making data changing easily detectable in blockchain. Ensuring data immutability is what blockchains strength is, and thats why it is the base level security mechanism used for saving data.

- Whats above base level?

Storing every single data transaction is unnessesary most of the time. Even if the base level blockchain has many tools; such as chain splitting, blockchain is inefficient to use for day to day data transactions, in terms of data throughput and data storage. There is a solution however, and that I propose is what bitcoin has done, but we take it a step further. It is a lightning network, built on top of the blockchain. A lightning network here is simply a protocol to establish communication securly between two or more parties. A lightning network protocol is useful when not transfering non-valuable data that doesnt need to be saved in history, as the lightning network doesnt save information in a database, like the blockchain does. The lightning network may prove more useful for valuable data transactions however, as you can exchange data transactions with each other almost instantly and without fees, but if one party does something to compromise the transactions you made with each other, the one party can dump the lightning network inforamtion onto the blockchain and have it saved there, disputing the comprimise. Heres an example, lets say bob sends alice 100 LNCH on a lightning network. Nobody else else besides bob and alice know this, so bob then goes and spends that 100 LNCH on the blockchain, where no one is the wiser. Alice notices this and dumps there lightning network data onto the blockchain, disputing what bob did. This example is very oversimplified, and there are other mechanisms that would act before this would even happen, but the point is given.

What hash function will be used? 
----------

Choosing a hash function is a tricky choice, so lets first lay out the options. Theres two types I will focus on for now, ASIC-resistent and non-ASIC-resistent hash functions. Lets also define hash functions clearly here: A hash function takes any size of input data and is able to produce a unique output. Most modern hash functions have a thing called high collision resistence, which basically means it is incredibly difficult to put in two different input datas, and get the same output data. Alright lets continue by also defining what an ASIC is. An ASIC is a computer chip that on a silicon level is built to only run one algorithm. Doing this makes the chip literally not able to do anything else, but makes it really fast and efficient at the algorithm its built for. Most hash functions are not ASIC-resistent, meaning ASIC chips can really easily be built to run them. ASIC-resistence as you can guess, means the algorithm is not easy to make an ASIC chip for. Lets look at the pros and cons for ASIC friendly algorithms.

Cons:
- Cons is easier to argue, so lets start there. When an algorithm is able to be ASIC'ed, and the goal is for the networks security to be decentralized, ASICs can make that fundementally more difficult. Heres why: When you can develop and ASIC chip, you can pack them in units for space efficientcy, cooling purposes, and to connect them all with a single control board. Examples being when you buy a Bitcoin ASIC, you are not buying a single chip, you are buying a unit of them, all packed together into a unit with fans. ASIC chips on there own may not cost much power, but whole units of them can take kilowatts of power. Bitcoin ASICs right now pretty much all take upwards of about 3.2kW to power, something the average person can not do in there home. This also comes at a cost of heat, so high pitch 80db fans are put on the unit to cool it, causing the space around to heat up, and uncomfortable amounts of noise to be produced. This is something the average person is not able to support in there house or apartment, meaning even if they could buy and power the unit, it still may not be possible to run for most people, decreasing decentralization. Most people also do not want or cant spend the money to buy a machine that only runs one algorithm.

- When a network is deployed, ASICs of the algorithm will likely not be the first to secure it, normal computers will. This means that if the network is mainly secured by normal computers, and an even party secured the money to develop themselves an ASIC, they can quickly take over the network much faster than the normal computers can counter. Lets use real numbers to show how much faster ASICs are to computers. If I used my graphics card (which is a 3060) to secure Bitcoin I would get; from what I understand, around 1-1.5 Giga-Hashes per second, for about 120 ish watts. The Bitcoin miner I have gets around 98,000 Giga-Hashes per second, for about 3500 watts. That is 65-98 thousand times faster for only 29 times the power cost. My computer is simply not able to compete on any level with that ASIC. With those numbers we can see that if 98 thousand different people joined the network with their computer, and then 1 person joined with an ASIC of this power, that 1 person would instantly control HALF of the whole networks security. Moral of the story here is that if the network is attacked by ASICs, and they gain the majority of the control easily, its game over.

Pros:
- Lets talk the pros and also mension the opposite of the last point I made in the cons. All algorithms at some point can be turned into an ASIC, thats why its called ASIC-resistent not ASIC-proof. This means if the network relies on ASICs for security, there is never a worry for the algorithm getting cracked and being taken over by ASICs. Even with networks like Ethereum that has an ASIC-resistent algorithm, ASICs have been developed (I am using 2400MH/s at 1920W in this example) and are about 48 times faster than the average graphics card (I am assumming 50MH/s at 130W) for only 14 times the power, ASICs are starting to outcompete the average computer. No worry about that with ASIC-friendly algorithms, meaning there is one less thing to be dependent on for security of the network (as mensioned before, this comes with the risk of an evil party using ASICs before everyone else does). 

- ASIC friendly algorithms are also just in general faster to run. Apart of making an algorithm resistent is to move the preformance bottleneck from raw processing power to something else, meaning the processing power of the hardware isnt able to be fully utilized. If the goal is to be fast, then making hashing faster will be more efficient for data processing.

What is the solution here?
- This may not be final, but here is what I propose:
First the hash function can use any size of memory to calculate the hash. More memory used does mean slower hashrate. Heres where it gets interesting. in the difficulty check to see whether your solution is correct, we can make it so solutions that used more memory are weighted higher in difficulty, meaning a solution from a gpu that used 8GB of memory will have higher difficulty than a solution from an ASIC that uses little to no memory. This eliminates the fear of ASICs taking over the network, as they technically can from day 1, but also allows gpus to keep up in a unique way.